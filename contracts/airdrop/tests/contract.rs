use cosmwasm_std::testing::{
    mock_dependencies, mock_env, mock_info, MockApi, MockQuerier, MockStorage, MOCK_CONTRACT_ADDR,
};
use cosmwasm_std::{
    coins, from_binary, BankMsg, CosmosMsg, Deps, Empty, Env, OwnedDeps, StdError, SubMsg,
    Timestamp, Uint128,
};

use mars_types::MarsMsg;

use mars_airdrop::contract::{execute, instantiate, query, sudo};
use mars_airdrop::msg::{ClaimedResponse, ExecuteMsg, InstantiateMsg, QueryMsg, SudoMsg};
use mars_airdrop::state::CLAIMED;

const MOCK_MERKLE_ROOT: &str = "a7da979c32f9ffeca6214558c560780cf06b09e52fe670f16c532b20016d7f38";

fn mock_env_at_timestamp(seconds: u64) -> Env {
    let mut env = mock_env();
    env.block.time = Timestamp::from_seconds(seconds);
    env
}

fn query_helper<T: serde::de::DeserializeOwned>(deps: Deps, env: Env, msg: QueryMsg) -> T {
    from_binary(&query(deps, env, msg).unwrap()).unwrap()
}

fn setup_test() -> OwnedDeps<MockStorage, MockApi, MockQuerier, Empty> {
    let mut deps = mock_dependencies();

    instantiate(
        deps.as_mut(),
        mock_env_at_timestamp(10000),
        mock_info("deployer", &[]),
        InstantiateMsg {
            merkle_root: MOCK_MERKLE_ROOT.to_string(),
        },
    )
    .unwrap();

    deps.querier.update_balance(MOCK_CONTRACT_ADDR, coins(1000000000, "umars"));

    deps
}

#[test]
fn claiming() {
    let mut deps = setup_test();

    // valid test case generated by `scripts/1_build_merkle_tree.ts` and `scripts/2_sign_messages.ts`
    let terra_acct_pk = "02306e8b60d390b54aa36a79b825dfebc49b1f3483a110c448a36db2bdfebed248";
    let terra_acct = "terra1757tkx08n0cqrw7p86ny9lnxsqeth0wgp0em95";
    let mars_acct = "mars1757tkx08n0cqrw7p86ny9lnxsqeth0wg6k6zj0";
    let amount = Uint128::new(42069);
    let proof = vec![
        "43e1c4776372ff2136f9f8db4f2c9e8392ebd9c378bf47eeba18871309c453d7".to_string(),
        "37c71107165d3dc28551f006263453fa642d78fc013c04d2d89d96de022fde24".to_string(),
        "7089ea1db485169381b9e3539e5c61e3818b53c03a34f8f2aeecf35a3e112c3a".to_string(),
    ];
    let signature = "a0927f2beea637682263e91afd39c2e11f987e41c3239cc6e6a6d8bb9f07decc27c69c02968da59567449d2baf8c24990ddf0a6457fb1e7c6187e1cc6723483e";

    // valid proof, valid signature
    let res = execute(
        deps.as_mut(),
        mock_env(),
        mock_info("claimer", &[]),
        ExecuteMsg::Claim {
            terra_acct_pk: terra_acct_pk.to_string(),
            mars_acct: mars_acct.to_string(),
            amount,
            proof: proof.clone(),
            signature: signature.to_string(),
        },
    )
    .unwrap();

    assert_eq!(res.messages.len(), 1);
    assert_eq!(
        res.messages[0],
        SubMsg::new(CosmosMsg::Bank(BankMsg::Send {
            to_address: mars_acct.to_string(),
            amount: coins(42069, "umars"),
        })),
    );

    // "claimed" should have been updated
    let claimed = CLAIMED.load(deps.as_ref().storage, terra_acct).unwrap();
    assert_eq!(claimed, Uint128::new(42069));

    // the same account cannot claim twice
    let err = execute(
        deps.as_mut(),
        mock_env(),
        mock_info("claimer", &[]),
        ExecuteMsg::Claim {
            terra_acct_pk: terra_acct_pk.to_string(),
            mars_acct: mars_acct.to_string(),
            amount,
            proof: proof.clone(),
            signature: signature.to_string(),
        },
    )
    .unwrap_err();

    assert_eq!(err, StdError::generic_err("account has already claimed"));

    // reset "claimed" for the next test
    CLAIMED.remove(deps.as_mut().storage, terra_acct);

    // invalid proof, valid signature
    let err = execute(
        deps.as_mut(),
        mock_env(),
        mock_info("claimer", &[]),
        ExecuteMsg::Claim {
            terra_acct_pk: terra_acct_pk.to_string(),
            mars_acct: mars_acct.to_string(),
            amount,
            proof: vec![
                "f3712e76d8b9288a381de1d22720fe3673d9e2636f1c11b2b26d6e7889a78692".to_string(),
                "37c71107165d3dc28551f006263453fa642d78fc013c04d2d89d96de022fde24".to_string(),
                "bff2934478464bb50326325e6b2a2d47ba13475eccfa991e9825442b06ae7efc".to_string(),
            ],
            signature: signature.to_string(),
        },
    )
    .unwrap_err();

    assert_eq!(err, StdError::generic_err("invalid proof"));

    // reset "claimed" for the next test
    CLAIMED.remove(deps.as_mut().storage, terra_acct);

    // valid proof, but invalid signature
    let err = execute(
            deps.as_mut(),
            mock_env(),
            mock_info("claimer", &[]),
            ExecuteMsg::Claim {
                terra_acct_pk: terra_acct_pk.to_string(),
                mars_acct: mars_acct.to_string(),
                amount,
                proof: proof.clone(),
                signature: "7f73595b39e4e8ed853e3fbe49ca32438e9a9b6f1f578dfa6acfda1d267c60953b749ba2b091b6058c0258db3f9231a4529651962b718b77db3e0ed8887e7cd1".to_string(),
            },
        )
        .unwrap_err();

    assert_eq!(err, StdError::generic_err("invalid signature"));
}

#[test]
fn querying_all_claimed() {
    let mut deps = setup_test();

    CLAIMED.save(deps.as_mut().storage, "larry", &Uint128::new(42069)).unwrap();
    CLAIMED.save(deps.as_mut().storage, "jake", &Uint128::new(69420)).unwrap();

    let res: Vec<ClaimedResponse> = query_helper(
        deps.as_ref(),
        mock_env(),
        QueryMsg::AllClaimed {
            start_after: None,
            limit: None,
        },
    );
    assert_eq!(
        res,
        vec![
            ClaimedResponse {
                terra_acct: "jake".to_string(),
                amount: Uint128::new(69420),
            },
            ClaimedResponse {
                terra_acct: "larry".to_string(),
                amount: Uint128::new(42069),
            }
        ],
    );
}

#[test]
fn clawing_back() {
    let mut deps = setup_test();

    let res = sudo(deps.as_mut(), mock_env(), SudoMsg::Clawback {}).unwrap();

    assert_eq!(res.messages.len(), 1);
    assert_eq!(
        res.messages[0],
        SubMsg::new(CosmosMsg::Custom(MarsMsg::FundCommunityPool {
            amount: coins(1000000000, "umars"),
        })),
    );
}
